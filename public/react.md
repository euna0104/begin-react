### 01. 리액트는 어쩌다 만들어졌을까?
1. 리액트는 Virtual DOM을 사용해서 만들었다.
2. Virtual DOM은 그냥 JS 객체이기 때문에 작동 성능이 실제로 브라우저에서 DOM을 보여주는 것 보다 속도가 훨씬 빠르다.
3. 리액트는 상태가 업데이트 되면, 업데이트가 필요한 곳의 UI를 Virtual DOM을 통해서 렌더링한다.
4. 그리고 나서 실제 브라우저에 보여지고 있는 DOM과 비교를 한 후, 차이가 있는 곳을 감지하여 이를 실제 DOM에 패치시켜준다.

### 03. 나의 첫번째 리액트 컴포넌트
1. 컴포넌트는 일종의 UI조각이다. 그리고, 쉽게 재사용 할 수 있다.
2. public/index.html 내부에 
```
<div id="root"></div> 
```
를 찾아볼 수 있다. 리액트 컴포넌트가 렌더링 될 때에는, 렌더링된 결과물이 위 div 내부테 렌더링 되는 것이다.
3. 리액트 컴포넌트에서는 XML 형식의 값을 반환해줄 수 있는데 이를 JSX라고 부른다.

### 04. JSX의 기본 규칙 알아보기
1. JSX 내부에 자바스크립트 변수를 보여줘야 할 때에는 {} 로 감싸서 보여준다.
2. JSX에서 태그에 style과 CSS class를 설정하는 방법은 HTML 에서 설정하는 방법과 다르다.
인라인 스타일은 객체 형태로 작성을 해야 하며, background-color 처럼 -로 구분되어 있는 이름들은 backgroundColor처럼 camelCase 형태로
작성해주어야 한다.
3. CSS class 를 설정 할 때에는 class=가 아닌 className= 으로 설정을 해주어야 한다.
4. 주석은 ```{/* 이런 형태 */}```로 작성한다.

### 05. props 를 통해 컴포넌트에게 값 전달하기
1. 우리가 어떠한 값을 컴포넌트에게 전달해줘야 할 때, props 를 사용한다.
2. 컴포넌트에게 전달되는 props는 파라미터를 통해 조회할 수 있다.
3. props는 객체 형태로 전달되며, 만약 ```name``` 값을 조회하고 싶다면 ```props.name```을 조회하면 된다.
4. 함수의 파라미터에서 비구조화 할당 (혹인 구조 분해) 문법을 사용하면 조금 더 코드를 간결하게 작성할 수 있다.
```
function Hello({ color, name }) {
    return <div style={{ color }}> 안녕하세요 {name}</div>
}
```
5. 컴포넌트에 props를 지정하지 않았을 때 기본적으로 사용할 값을 설정하고 싶다면 컴포넌트에 ```defaultProps``` 라는 값을 설정한다.
```
Hello.defaultProps = {
    name: '이름없음'
}
```
6. 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐, ```props.children```을 조회하면 된다. 
ex) 내부의 내용이 보여지게 하기 위해서는 Wrapper 에서 ```props.children``` 을 렌더링해주어야 한다.
```
function Wrapper({ children }) {
    const style = {
        border: '2px solid black',
        padding: '16px'
    };
    return (
        <div style={style}>
            {children}
        </div>
    )
}
```

### 06. 조건부 렌더링
1. 조건브 렌더링이란, 특정 조건에 따라 다른 결과물을 렌더링 하는 것을 의미한다.
```
<Hello name="react" color="red" isSpecial={true}/> // App.js
```
```agsl
 <div style={{ color }}>
      { isSpecial ? <b>*</b> : null }
      안녕하세요 {name}
 </div> // Hello.js
```
3. 컴포넌트의 props 값을 설정하게 될 때 만약 props 이름만 작성하고 값 설정을 생략한다면, 이를 ```true``` 로 설정한 것으로 간주한다.
```agsl
<Hello name="react"  color="red" isSpecial /> // App.js
```

### 07. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기
1. 캄포넌트에서 보여줘야 하는 내용이 사용자 인터렉션에 따라 바뀌어야 할 때 어떻게 구현할 수 있는지에 대해 알아보겠다.
2. 리액트 16.8에서 Hooks라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다.
3. useState 함수는 리액트의 Hooks 중 하나다.
4. 컴포넌트에서 동적인 값을 상태(state)라고 부른다.

### 08. input 상태 관리하기 
1. input의 ```onChange``` 라는 이벤트를 사용한다.
이벤트에 등록하는 함수에서는 이벤트 객체 ```e```를 파라미터로 받아와서 사용할 수 있다.
이 객체의 ```e.target``` 은 이벤트가 발생한 DOM인 input DOM 을 가르키게 된다.
DOM 의 ```value``` 값, 즉 ```e.target.value``` 를 조회하면 현재 input 에 입력한 값이 무엇인지 알 수 있다.
이 값을 ```useState``` 를 통해서 관리를 해주면 된다.

### 09. 여러개의 input 상태 관리하기
1. input 의 개수가 여러개가 됐을때는, 단순히 ```useState``` 를 여러번 사용하고 ```onChange``` 도 여러개 만들어서 구현할 수 있다. 
-> 하지만 이러한 방법은 좋은 방법이 아니다.
2. 더 좋은 방법은 input에 ```name``` 을 설정하고 이벤트가 발생했을 때 이 값을 참조하는 것 이다.
3. 그리고 ```useState``` 에서는 문자열이 아니라 객체 형태의 상태를 관리해주어야 한다.

### 10. useRef 로 특정 DOM 선택하기
1. 함수형 컴포넌트에서 ```ref``` 를 사용할 때에는 ```useRef``` 라는 Hook 함수를 사용한다.

### 11. 배열 렌더링하기
1. 동적인 배열을 렌더링해야 할 때에는 자바스크립트 배열의 내장함수 ```map()``` 을 사용한다. 
2. ```map()``` 함수는 배열안에 있는 각 원소를 변환하여 새로운 배열을 만들어준다.
3. 리액트에서 동적인 배열을 렌더링해야 할 때는 이 함수를 사용하여 일반 데이터 배열을 리액트 엘리먼트로 이루어진 배열로 변환해주면 된다.
4. 리액트에서 배열을 렌더링 할 때에는 ```key``` 라는 props 를 설정해야한다.
5. ```key``` 값은 각 원소들마다 가지고 있는 고유값으로 설정을 해야한다.
6. 만약 배열 안의 원소가 가지고 있는 고유한 값이 없다면 ```map()``` 함수를 사용 할 때 설정하는 콜백함수의 두번째 파라미터 ```index```를
```key```로 사용하면 된다.
```agsl
<div>
  {users.map((user, index) => (
    <User user={user} key={index} />
  ))}
</div>
```

### 12. useRef로 컴포넌트 안의 변수 만들기
1. ```useRef``` Hook 은 DOM 을 선택하는 용도 외에, 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리할 수 있다.
2. ```useRef()``` 를 사용할 때 파라미터를 넣어주면, 이 값이 ```.current``` 값의 기본값이 된다.

### 13. 배열에 항목 추가하기
1. 배열에 새로운 항목을 <b>추가</b> 하는 방법을 알아보겠다.
2. 배열에 변화를 줄 때에는 객체와 마찬가지로, 불변성을 지켜주어야 한다.
그렇기 때문에, 배열의 ```push, slice, sort``` 등의 함수를
사용하면 안된다.
3. 만약에 사용해야 한다면, 기존의 배열을 한번 복사하고 나서 사용해야한다.
4. 불변성을 지키면서 배열에 새 항목을 추가하는 방법은 두가지가 있다. (1) spread 연산자 (2) concat함수 사용
5. ```concat``` 함수는 기존의 배열을 수정하지 않고, 새로운 원소가 추가된 새로운 배열을 만들어준다.

### 14. 배열에 항목 제거하기
1. 불변성을 지키면서 특정 원소를 배열에서 제거하기 위해서는 ```filter``` 배열 내장 함수를 사용하는 것이 가장 편하다.
2. 이 함수는 배열에서 특정 조건이 만족하는 원소들만 추출하여 새로운 배열을 만들어준다.

### 15. 배열 항목 수정하기
1. onRemove, onToggle 등의 함수 리터럴을 App.js 에서 선언해서, 하위 컴포넌트에게 이벤트 핸들러 방식으로 전달해준다.

### 16. useEffect를 사용하여 마운트/언마운트/업데이트 시 할 작업 설정하기
1. ```useEffect``` 에서는 함수를 반환 할 수 있는데 이를 ```cleanup``` 함수라고 부른다.
2. 마운트 시에 하는 작업들은 다음과 같은 사항들이 있다.
- ```props``` 로 받은 값을 컴포넌트의 로컬 상태로 설정
- 외부 API 요청
- 라이브러리 사용
- setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약
3. ```deps``` 에 특정 값을 넣게 된다면, 컴포넌트가 처음 마운트 될 때에도 호출이 되고, 지정한 값이 바뀔 때에도 호출이 된다.
4. ```deps``` 파라미터를 생략한다면, 컴포넌트가 리렌더링 될 때마다 호출된다.
5. 리액트는 부모 컴포넌트가 리렌더링 되면, 자식 컴포넌트 또한 리렌더링이 된다. (바뀐 내용이 없더라도)

### 17. useMemo 를 사용하여 연산한 값 재사용하기
1. ```useMemo``` 라는 Hook 함수를 사용하면 성능을 최적화할 수 있다.
2. Memo 는 "memoized"를 의미하는데, 이잔에 계산 한 값을 재사용한다는 의미를 가지고 있다.
3. ```const count = useMemo(() => countActiveUsers(users), [users]);```
```useMemo``` 의 첫번째 파라미터에는 어떻게 연산할지 정의하는 함수를 넣어주면 되고 두번째 파라미터에는 deps 배열을 넣어주면 된다.
4. deps 배열 안에 넣은 내용이 바뀌면, 우리가 등록한 함수를 호출해서 값을 연산해주고, 
만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다.

### 18. useCallback 을 사용하여 함수 재사용하기
1. ```useCallback```은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.
2. 주의할 점은, 함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, ```deps``` 배열 안에 포함시켜야 된다.
3. ```deps``` 배열 안에 함수에서 사용하는 값을 넣지 않게 된다면, 함수 내에서 해당 값들을 참조할 때 가장 최신 값을 참조할 것이라고 
보장할 수 없다.

### 19. React.memo 를 사용한 컴포넌트 리렌더링 방지
1. React.memo 는 컴포넌트의 props 가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해줄 수 있다.
2. 이 함수를 사용한다면, 컴포넌트에서 리렌더링 필요한 상황에서만 리렌더링을 하도록 설정해줄 수 있다.
3. 그런데, ```React.memo```를 사용하더라도, 하나라도 수정하면 모든 User 들이 리렌더링되고, CreateUser 도 리렌더링 된다.
-> 이 이유로는 users의 배열이 바뀔때마다 onCreate 도 새로 만들어지고, onToggle, onRemove도 새로 만들어지기 때문이다.
4. ```deps```에 ```users```가 들어있기 때문에 배열이 바뀔때마다 함수가 새로 만들어지는건, 당연하다.
-> 이를 최적화 하려면 ```deps```에서 ```users```를 지우고, 
함수들에서 현재 ```useState```로 관리하는 ```users```를 참조하지 않게 하는 것이다. 즉 ```함수형 업데이트```사용
5. 함수형 업데이트를 하게 되면 ```setUsers```에 등록하는 콜백함수의 파라미터에서 최신 ```users```를 참조할 수 있기 때문에 
```deps```에 ```users```를 넣지 않아도 된다.

### 20. useReducer를 사용하여 상태 업데이트 로직 분리하기
1. useReducer를 사용하면 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있다.
2. 상태 업데이트 로직을 컴포넌트 바깥에 작성할 수도 있고, 심지어 다른 파일에 작성 후 불러와서 사용할 수도 있다.
3. reducer는 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수다.
```agsl
function reducer(state, action) {
  return nextState;
}

```
4. ```useReducer```의 사용법
```agsl
const [state, dispatch] = useReducer(reducer, initialState);
```
여기서 ```state```는 우리가 앞으로 컴포넌트에서 사용할 수 있는 상태를 가르키게 되고,
```dispatch```는 액션을 발생시키는 함수다.
5. ```useReducer```에 넣는 첫번째 파라미터는 reducer 함수이고, 두번째 파라미터는 초기상태다.