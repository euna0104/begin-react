#### 1장. 리액트 입문
### 01. 리액트는 어쩌다 만들어졌을까?
1. 리액트는 Virtual DOM을 사용해서 만들었다.
2. Virtual DOM은 그냥 JS 객체이기 때문에 작동 성능이 실제로 브라우저에서 DOM을 보여주는 것 보다 속도가 훨씬 빠르다.
3. 리액트는 상태가 업데이트 되면, 업데이트가 필요한 곳의 UI를 Virtual DOM을 통해서 렌더링한다.
4. 그리고 나서 실제 브라우저에 보여지고 있는 DOM과 비교를 한 후, 차이가 있는 곳을 감지하여 이를 실제 DOM에 패치시켜준다.

### 03. 나의 첫번째 리액트 컴포넌트
1. 컴포넌트는 일종의 UI조각이다. 그리고, 쉽게 재사용 할 수 있다.
2. public/index.html 내부에 
```
<div id="root"></div> 
```
를 찾아볼 수 있다. 리액트 컴포넌트가 렌더링 될 때에는, 렌더링된 결과물이 위 div 내부테 렌더링 되는 것이다.
3. 리액트 컴포넌트에서는 XML 형식의 값을 반환해줄 수 있는데 이를 JSX라고 부른다.

### 04. JSX의 기본 규칙 알아보기
1. JSX 내부에 자바스크립트 변수를 보여줘야 할 때에는 {} 로 감싸서 보여준다.
2. JSX에서 태그에 style과 CSS class를 설정하는 방법은 HTML 에서 설정하는 방법과 다르다.
인라인 스타일은 객체 형태로 작성을 해야 하며, background-color 처럼 -로 구분되어 있는 이름들은 backgroundColor처럼 camelCase 형태로
작성해주어야 한다.
3. CSS class 를 설정 할 때에는 class=가 아닌 className= 으로 설정을 해주어야 한다.
4. 주석은 ```{/* 이런 형태 */}```로 작성한다.

### 05. props 를 통해 컴포넌트에게 값 전달하기
1. 우리가 어떠한 값을 컴포넌트에게 전달해줘야 할 때, props 를 사용한다.
2. 컴포넌트에게 전달되는 props는 파라미터를 통해 조회할 수 있다.
3. props는 객체 형태로 전달되며, 만약 ```name``` 값을 조회하고 싶다면 ```props.name```을 조회하면 된다.
4. 함수의 파라미터에서 비구조화 할당 (혹인 구조 분해) 문법을 사용하면 조금 더 코드를 간결하게 작성할 수 있다.
```
function Hello({ color, name }) {
    return <div style={{ color }}> 안녕하세요 {name}</div>
}
```
5. 컴포넌트에 props를 지정하지 않았을 때 기본적으로 사용할 값을 설정하고 싶다면 컴포넌트에 ```defaultProps``` 라는 값을 설정한다.
```
Hello.defaultProps = {
    name: '이름없음'
}
```
6. 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐, ```props.children```을 조회하면 된다. 
ex) 내부의 내용이 보여지게 하기 위해서는 Wrapper 에서 ```props.children``` 을 렌더링해주어야 한다.
```
function Wrapper({ children }) {
    const style = {
        border: '2px solid black',
        padding: '16px'
    };
    return (
        <div style={style}>
            {children}
        </div>
    )
}
```

### 06. 조건부 렌더링
1. 조건브 렌더링이란, 특정 조건에 따라 다른 결과물을 렌더링 하는 것을 의미한다.
```
<Hello name="react" color="red" isSpecial={true}/> // App.js
```
```agsl
 <div style={{ color }}>
      { isSpecial ? <b>*</b> : null }
      안녕하세요 {name}
 </div> // Hello.js
```
3. 컴포넌트의 props 값을 설정하게 될 때 만약 props 이름만 작성하고 값 설정을 생략한다면, 이를 ```true``` 로 설정한 것으로 간주한다.
```agsl
<Hello name="react"  color="red" isSpecial /> // App.js
```

### 07. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기
1. 캄포넌트에서 보여줘야 하는 내용이 사용자 인터렉션에 따라 바뀌어야 할 때 어떻게 구현할 수 있는지에 대해 알아보겠다.
2. 리액트 16.8에서 Hooks라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었다.
3. useState 함수는 리액트의 Hooks 중 하나다.
4. 컴포넌트에서 동적인 값을 상태(state)라고 부른다.

### 08. input 상태 관리하기 
1. input의 ```onChange``` 라는 이벤트를 사용한다.
이벤트에 등록하는 함수에서는 이벤트 객체 ```e```를 파라미터로 받아와서 사용할 수 있다.
이 객체의 ```e.target``` 은 이벤트가 발생한 DOM인 input DOM 을 가르키게 된다.
DOM 의 ```value``` 값, 즉 ```e.target.value``` 를 조회하면 현재 input 에 입력한 값이 무엇인지 알 수 있다.
이 값을 ```useState``` 를 통해서 관리를 해주면 된다.

### 09. 여러개의 input 상태 관리하기
1. input 의 개수가 여러개가 됐을때는, 단순히 ```useState``` 를 여러번 사용하고 ```onChange``` 도 여러개 만들어서 구현할 수 있다. 
-> 하지만 이러한 방법은 좋은 방법이 아니다.
2. 더 좋은 방법은 input에 ```name``` 을 설정하고 이벤트가 발생했을 때 이 값을 참조하는 것 이다.
3. 그리고 ```useState``` 에서는 문자열이 아니라 객체 형태의 상태를 관리해주어야 한다.

### 10. useRef 로 특정 DOM 선택하기
1. 함수형 컴포넌트에서 ```ref``` 를 사용할 때에는 ```useRef``` 라는 Hook 함수를 사용한다.

### 11. 배열 렌더링하기
1. 동적인 배열을 렌더링해야 할 때에는 자바스크립트 배열의 내장함수 ```map()``` 을 사용한다. 
2. ```map()``` 함수는 배열안에 있는 각 원소를 변환하여 새로운 배열을 만들어준다.
3. 리액트에서 동적인 배열을 렌더링해야 할 때는 이 함수를 사용하여 일반 데이터 배열을 리액트 엘리먼트로 이루어진 배열로 변환해주면 된다.
4. 리액트에서 배열을 렌더링 할 때에는 ```key``` 라는 props 를 설정해야한다.
5. ```key``` 값은 각 원소들마다 가지고 있는 고유값으로 설정을 해야한다.
6. 만약 배열 안의 원소가 가지고 있는 고유한 값이 없다면 ```map()``` 함수를 사용 할 때 설정하는 콜백함수의 두번째 파라미터 ```index```를
```key```로 사용하면 된다.
```agsl
<div>
  {users.map((user, index) => (
    <User user={user} key={index} />
  ))}
</div>
```

### 12. useRef로 컴포넌트 안의 변수 만들기
1. ```useRef``` Hook 은 DOM 을 선택하는 용도 외에, 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리할 수 있다.
2. ```useRef()``` 를 사용할 때 파라미터를 넣어주면, 이 값이 ```.current``` 값의 기본값이 된다.

### 13. 배열에 항목 추가하기
1. 배열에 새로운 항목을 <b>추가</b> 하는 방법을 알아보겠다.
2. 배열에 변화를 줄 때에는 객체와 마찬가지로, 불변성을 지켜주어야 한다.
그렇기 때문에, 배열의 ```push, slice, sort``` 등의 함수를
사용하면 안된다.
3. 만약에 사용해야 한다면, 기존의 배열을 한번 복사하고 나서 사용해야한다.
4. 불변성을 지키면서 배열에 새 항목을 추가하는 방법은 두가지가 있다. (1) spread 연산자 (2) concat함수 사용
5. ```concat``` 함수는 기존의 배열을 수정하지 않고, 새로운 원소가 추가된 새로운 배열을 만들어준다.

### 14. 배열에 항목 제거하기
1. 불변성을 지키면서 특정 원소를 배열에서 제거하기 위해서는 ```filter``` 배열 내장 함수를 사용하는 것이 가장 편하다.
2. 이 함수는 배열에서 특정 조건이 만족하는 원소들만 추출하여 새로운 배열을 만들어준다.

### 15. 배열 항목 수정하기
1. onRemove, onToggle 등의 함수 리터럴을 App.js 에서 선언해서, 하위 컴포넌트에게 이벤트 핸들러 방식으로 전달해준다.

### 16. useEffect를 사용하여 마운트/언마운트/업데이트 시 할 작업 설정하기
1. ```useEffect``` 에서는 함수를 반환 할 수 있는데 이를 ```cleanup``` 함수라고 부른다.
2. 마운트 시에 하는 작업들은 다음과 같은 사항들이 있다.
- ```props``` 로 받은 값을 컴포넌트의 로컬 상태로 설정
- 외부 API 요청
- 라이브러리 사용
- setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약
3. ```deps``` 에 특정 값을 넣게 된다면, 컴포넌트가 처음 마운트 될 때에도 호출이 되고, 지정한 값이 바뀔 때에도 호출이 된다.
4. ```deps``` 파라미터를 생략한다면, 컴포넌트가 리렌더링 될 때마다 호출된다.
5. 리액트는 부모 컴포넌트가 리렌더링 되면, 자식 컴포넌트 또한 리렌더링이 된다. (바뀐 내용이 없더라도)

### 17. useMemo 를 사용하여 연산한 값 재사용하기
1. ```useMemo``` 라는 Hook 함수를 사용하면 성능을 최적화할 수 있다.
2. Memo 는 "memoized"를 의미하는데, 이잔에 계산 한 값을 재사용한다는 의미를 가지고 있다.
3. ```const count = useMemo(() => countActiveUsers(users), [users]);```
```useMemo``` 의 첫번째 파라미터에는 어떻게 연산할지 정의하는 함수를 넣어주면 되고 두번째 파라미터에는 deps 배열을 넣어주면 된다.
4. deps 배열 안에 넣은 내용이 바뀌면, 우리가 등록한 함수를 호출해서 값을 연산해주고, 
만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다.

### 18. useCallback 을 사용하여 함수 재사용하기
1. ```useCallback```은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.
2. 주의할 점은, 함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, ```deps``` 배열 안에 포함시켜야 된다.
3. ```deps``` 배열 안에 함수에서 사용하는 값을 넣지 않게 된다면, 함수 내에서 해당 값들을 참조할 때 가장 최신 값을 참조할 것이라고 
보장할 수 없다.

### 19. React.memo 를 사용한 컴포넌트 리렌더링 방지
1. React.memo 는 컴포넌트의 props 가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해줄 수 있다.
2. 이 함수를 사용한다면, 컴포넌트에서 리렌더링 필요한 상황에서만 리렌더링을 하도록 설정해줄 수 있다.
3. 그런데, ```React.memo```를 사용하더라도, 하나라도 수정하면 모든 User 들이 리렌더링되고, CreateUser 도 리렌더링 된다.
-> 이 이유로는 users의 배열이 바뀔때마다 onCreate 도 새로 만들어지고, onToggle, onRemove도 새로 만들어지기 때문이다.
4. ```deps```에 ```users```가 들어있기 때문에 배열이 바뀔때마다 함수가 새로 만들어지는건, 당연하다.
-> 이를 최적화 하려면 ```deps```에서 ```users```를 지우고, 
함수들에서 현재 ```useState```로 관리하는 ```users```를 참조하지 않게 하는 것이다. 즉 ```함수형 업데이트```사용
5. 함수형 업데이트를 하게 되면 ```setUsers```에 등록하는 콜백함수의 파라미터에서 최신 ```users```를 참조할 수 있기 때문에 
```deps```에 ```users```를 넣지 않아도 된다.

### 20. useReducer를 사용하여 상태 업데이트 로직 분리하기
1. useReducer를 사용하면 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있다.
2. 상태 업데이트 로직을 컴포넌트 바깥에 작성할 수도 있고, 심지어 다른 파일에 작성 후 불러와서 사용할 수도 있다.
3. reducer는 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수다.
```agsl
function reducer(state, action) {
  return nextState;
}

```
4. ```useReducer```의 사용법
```agsl
const [state, dispatch] = useReducer(reducer, initialState);
```
여기서 ```state```는 우리가 앞으로 컴포넌트에서 사용할 수 있는 상태를 가르키게 되고,
```dispatch```는 액션을 발생시키는 함수다.
5. ```useReducer```에 넣는 첫번째 파라미터는 reducer 함수이고, 두번째 파라미터는 초기상태다.

### 22. Context API를 사용한 전역 값 관리
1. 리액트의 Context API를 사용하면, 프로젝트 안에서 전역적으로 사용할 수 있는 값들을 관리할 수 있다.

### 23. Immer 를 사용한 더 쉬운 불변성 관리
1. 리액트에서 배열이나 객체를 업데이트 해야 할 때에는 직접 수정 하면 안되고 불변성을 지켜주면서 업데이트를 해주어야 한다.
2. ...연산자를 사용해서 새로운 객체를 만들어줘야 한다.
3. 배열도 마찬가지로, ```push, filter, map``` 등의 함수를 사용하더나 n번째 항목을 직접 수정하면 안되고
다음과 같이 ```concat, filter, map``` 등의 함수를 사용해야 한다.
4. Immer 를 사용하면 우리가 상태를 업데이트 할 때, 불변성을 신경쓰지 않으면서 업데이트를 해주면 Immer 가 불변성 관리를 대신 해준다.
5. 코드의 상단에서 immer 를 불러와줘야한다. 보통 ```produce``` 라는 이름으로 불러온다.
```agsl
import produce from 'immer';
```
6. ```produce``` 함수를 사용할 때에는 첫번째 파라미터에는 수정하고 싶은 상태, 
두번째 파라미터에는 어떻게 업데이트 하고 싶을지 정의하는 함수를 넣어준다.
```agsl
const nextState = produce(state, draft => {
  draft.number += 1;
});
```

### 24. 클래스형 컴포넌트
1. 옛날에 만들어진 리액트 관련 라이브러리의 경우에는 Hooks 지원이 아직 안되는 경우도 있고, react-native 관련 라우터 라이브러리인 
```react-native-navigation``` 의 경우에도 클래스형 컴포넌트를 어쩔 수 없이 써야하는 일이 종종 있다.
2. 요즘은 함수형 컴포넌트를 사용한다.
3. 클래스형 컴포넌트에서는 ```render()``` 메서드가 꼭 있어야한다. 이 메서드에서 렌더링하고 싶은 JSX를 반환하면 된다.
4. ```props``` 를 조회해야 할 때에는 ```this.props```를 조회하면 된다.
5. 클래스형 컴포넌트에서는 render 함수 내부에서 선언은 할 수 있기는 있지만, 일반적으로 클래스 안에 커스텀 메서드를 선언한다.
6. 클래스 내부에 종속된 함수를 '메서드' 라고 부른다. 
클래스에서 커스텀 메서드를 만들게 될 때에는 보통 이름을 ```handle...``` 이라고 이름을 짓는다.
7. 우리가 추후 상태를 업데이트 할 때에는 이 메서드에서 ```this.state``` 라는 함수를 사용해야 한다.
8. 메서드와 컴포넌트 인스턴스의 관계가 끊어지는 현상을 해결하기 위해서 할 수 있는 방법은 총 3가지가 있다.
   (1) 클래스의 생성자 메서드 ```constructor``` 에서 ```bind``` 작업을 해주는 것
9. 클래스형 컴포넌트에서 상태를 관리할 때에는 ```state```라는 것을 사용한다. 
10. ```state```를 선언할 때에는 ```constructor``` 내부에서 ```this.state```를 설정해주면 된다.
11. 클래스형 컴포넌트의 ```state``` 는 무조건 객체형태여야 한다.
12. ```render``` 메서드에서 ```state``` 를 조회하려면 ```this.state``` 를 조회하면 된다.
13. 상태를 업데이트해야 할 때에는 ```this.setState``` 함수를 사용하면 된다.

<br></br>
#### 3장. 투두리스트 만들기
### 01. 컴포넌트 만들기
1. TodoTemplate
- 우리가 만들 투두리스트의 레이아웃을 설정하는 컴포넌트다. 페이지의 중앙에 그림자가 적용된 흰색 박스를 보여준다.
2. TodoHead
- 오늘의 날짜와 요일을 보여주고, 앞으로 해야 할 일이 몇개 남았는지 보여준다.
3. TodoList
- 할 일에 대한 정보가 들어있는 todos 배열을 내장함수 ```map ``` 을 사용하여 여러개의 TodoItem 컴포넌트를 렌더링 해준다.
4. TodoItem
- 각 할 일에 대한 정보를 렌더링 해주는 컴포넌트다. 
- 좌측에 있는 원을 누르면 할 일의 완료 여부를 toggle 할 수 있다.
- 할 일이 완료됐을 땐 좌측에 체크가 나타나고 텍스트의 색상이 연해진다.
- 그리고, 마우스를 올리면 휴지통 아이콘이 나타나고 이를 누르면 항목이 삭제된다.
5. TodoCreate
- 새로운 할 일을 등록할 수 있게 해주는 컴포넌트.
- TodoTemplate 의 하단부에 초록색 원 버튼을 렌더링해주고, 이를 클릭하면 할 일을 입력 할 수 있는 폼이 나타난다.
- 버튼을 다시 누르면 폼이 사라진다.
